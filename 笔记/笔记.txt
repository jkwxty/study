[TOC]





<blockquote>标签示例</blockquote>

<font color="Salmon" size="4">标签示例</font>

# nacos

## nacos相关版本依赖

------

父工程：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>nacos</artifactId>
  <packaging>pom</packaging>
  <version>0.0.1-SNAPSHOT</version>
  <modules>
    <module>order-nacos</module>
    <module>stock-nacos</module>
  </modules>
  <name>nacos</name>
  <description>Demo project for Spring Boot</description>

  <properties>
    <java.version>1.8</java.version>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
        <version>2.0.10</version>
      </dependency>
      <!--spring cloud alibaba版本管理      -->
      <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-alibaba-dependencies</artifactId>
        <version>2.2.5.RELEASE</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!--springboot版本管理      -->
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.3.11.RELEASE</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!--spring cloud版本管理      -->
      <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>Hoxton.SR9</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
          <encoding>UTF-8</encoding>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <version>2.3.7.RELEASE</version>
        <configuration>
          <mainClass>com.example.nacos.NacosApplication</mainClass>
        </configuration>
        <executions>
          <execution>
            <id>repackage</id>
            <goals>
              <goal>repackage</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

</project>

```



子工程

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <parent>
    <artifactId>nacos</artifactId>
    <groupId>com.example</groupId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <modelVersion>4.0.0</modelVersion>

  <artifactId>order-nacos</artifactId>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
  </dependencies>

</project>
```

[^1]: 注意spring和spring-cloud-alibaba版本之间的关系

[版本对应关系](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E ) 

[nacos注册中心文档地址](https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery)

[nacos配置中心文档地址](https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config)

[Linux 服务器上搭建nacos服务端 ](https://blog.csdn.net/qq_46112274/article/details/123117926) ps:自己买的服务器内存不够，nacos集群搭建不了，只能实现单机版nacos~~



## nacos的使用

```yml
spring:
  application:
    name: order-service
  cloud:
    nacos:
      server-addr: 139.159.198.7:8849
      username: nacos
      password: nacos
      discovery:
        namespace: dev
      config:
        #命名空间
        namespace: dev
        #更细粒度的分组
        group: group1
        #配置文件前缀
        prefix: order-config
        #配置文件后缀
        file-extension: properties
        #下标越大，优先级越高
        extension-configs:
          - data-id: order-config-sit.properties
            refresh: true
          - data-id: order-config-sit02.properties
            refresh: true
        shared-configs[0]:
          data-id: order-config-sit.properties
          group: group1
          refresh: true
##优先级 profile>默认配置文件>extension-configs>shared-configs

```





学习完注册中心和配置中心的基本使用，但是还不清楚其中原理，有时间需要去搞懂！

nacos注册中心是使用什么方式进行远程调用的？



学习计划：

​	搭建nexus私服-->nacos 注册中心整合openFign

------

# Maven管理工具 NEXUS 搭建  

[nexus下载地址](https://help.sonatype.com/docs)

pom：

```
<distributionManagement>
  <repository>
    <id>releases</id>
    <name>Nexus Release</name>
    <url>http://139.159.198.7:8081/nexus/content/repositories/releases/</url>
  </repository>

  <snapshotRepository>
    <id>snapshots</id>
    <name>Nexus SNAPSHOTS</name>
    <url>http://139.159.198.7:8081/nexus/content/repositories/snapshots/</url>
  </snapshotRepository>
</distributionManagement>
```

maven setting文件：

```xml
</server>

    <!-- Another sample, using keys to authenticate.-->
    <server>
        <id>release</id>
        <privateKey>admin</privateKey>
        <passphrase>admin123</passphrase>
    </server>
	<server>
      <id>snapshots</id>
      <privateKey>admin</privateKey>
      <passphrase>admin123</passphrase>
    </server>
</servers>

<mirror>
    <!-- id：可自定义 -->
    <id>nexus-mine</id>
    <!-- mirrorOf：配置成 * 表示通过 nexus 访问网路上所有的远程仓库；配置成central，表示访问 nexus 的central仓库； -->
    <mirrorOf>central</mirrorOf>
    <!-- name：可自定义 -->
    <name>Nexus mine</name>
    <!-- url：仓库地址 -->
    <url>http://139.159.198.7:8081/nexus/content/groups/public/</url>
</mirror>
```



# [springalibaba教程](https://www.bilibili.com/video/BV1pF41147Aa?p=2&vd_source=66b43a603a98f45e95e059fb7bdd3c36) 相关笔记

## 微服务概念：

### 	服务架构演变流程

​	单体架构->垂直架构->分布式架构->SOA架构->微服务架构



​	单体架构：

​		优点：架构简单，开发成本低。项目部署在一个节点上，便于维护 (基于小型项目)

​		缺点：对于大型项目来说，不易于开发和维护，项目模块耦合大，单点容错率底(一旦服务出BUG 导致所有模块都不能用)，无法针对不同模块进行水平扩展



​	垂直架构：

​		优点：

1. 系统拆分实现流量分组，解决并发问题，可以争对不同模块进行优化和水平扩展
2. 一个系统产生的问题不会影像另一个系统，相互独立的，提搞容错率

​		缺点：

1. 无法进行互相调用，会有重复的开发任务

   

   OA,MES,WMS,供应链系统 一般采用的是这种垂直拆分			

​	分布式架构：

​		优点：

1. 抽取公共的功能作为服务层，提高代码复用性

​		缺点：

1. 系统间的耦合度变高，调用关系错综复杂，难以维护



​	SOA架构：

​		优点：

1. 使用治理中心(ESB/dubbo) 解决了服务间调用关系的自动调节

​		缺点：

1. 服务间会有依赖关系，一旦某个环节节点出错，影像会比较大(服务雪崩)
2. 服务关系负责，运维，测试，部署困难

​	微服务架构：

​		优点：

1. 服务原子化拆分，独立打包 部署和升级，保证每个微服务清晰的划分任务，利于扩展
2. 微服务之前采用Restful等轻量级http协议相互调用

​		缺点：

1. 分布式系统开发的技术成本高(容错，分布式事务等)
2. 复杂性更高。各个微服务进行分布式独立部署，当进行模块调用时，分布式会变得更麻烦



## Ribbon

Spring cloud Ribbon 是基于NetflixRibbon实现的一套基于客户端负载均衡工具

### 分类

客户端负载均衡：客户端会有一个服务列表，在发送请求之前，会在客户端通过负载均衡算法选择一个服务器，然后进行访问，	这就是客户端负载均衡。即在客户端就进行负载均衡算法分配，一般有Ribbon

服务端负载均衡：先发送请求，然后通过负载均衡算法，在多个服务器之前选择一个进行访问；即在服务端再进行负载均衡算法	分配。例如：nginx



### 常见的负载均衡策略

​	随机，轮询，加权轮询，地址hash,最小链接数

### ribbon的使用

1 配置类+注解

​	配置类：

```java
@Configuration
public class RibbonConfig {

  @Bean
  public IRule iRule(){
    return new RoundRobinRule();
  }

}


//启动类
@SpringBootApplication
@RibbonClients(value =
    {
        @RibbonClient(name = "stock-service",configuration = RibbonConfig.class)
    }
)
public class OrderServer {

  @Bean
  @LoadBalanced
  public RestTemplate restTemplate(){
    return new RestTemplate();
  }

  public static void main(String[] args) {
    ConfigurableApplicationContext run = SpringApplication.run(OrderServer.class, args);
  }
}



```

2 配置文件指定Irul接口的实现类

​	

```yml
##争对某个被调用服务配置负载均衡策略，这里是订单服务调用stock-service服务时，配置的负载均衡策略为自定义的负载均衡策略-MyCustomerLoadBalancerRule
stock-service: ##服务名称
  ribbon:
  	 ##可以是已有的Irule实现类(eg:NacosRule,RandomRule)，也可以是自定义的Irule实现类
    NFLoadBalancerRuleClassName: com.it.alibaba.customer.MyCustomerLoadBalancerRule
```

```java
public class MyCustomerLoadBalancerRule extends AbstractLoadBalancerRule {

  @Override
  public void initWithNiwsConfig(IClientConfig iClientConfig) {

  }

  @Override
  public Server choose(Object o) {
    ILoadBalancer loadBalancer = this.getLoadBalancer();
    List<Server> allServers = loadBalancer.getAllServers();
    Map<Integer, MetaInfo> serverMap = allServers.stream()
        .collect(Collectors.toMap(Server::getPort, Server::getMetaInfo));
    if(serverMap!=null&&serverMap.size()>0){
      serverMap.forEach((key,value)->{
        System.out.println("端口："+key+"==="+"服务名:"+value.getAppName());
      });
    }
    int i = ThreadLocalRandom.current().nextInt(allServers.size());
    return allServers.get(i);
  }
}
```

### 使用时需要注意的问题

​		 1 如果使用的是配置类方式配置负载均衡策略，那么，我们的配置类不能放在@CompomentScan能扫描到的包下面，否则这个在配置了多个服务的情况下，这个配置类会全局共享，其他配置不生效



###### 

### Openfeign

#### 什么是feign

Feign是Netflix开发的 声明式 模板化的http客户端，可以帮助我们更加快捷，优雅的调用http api。-- feign内部也整合了负载均衡器

由于netflix feign闭源了，spring cloud对feign进行了增强，推出了OpenFeign,使其支持Spring mvc注解，另外还整合了Nacos和Ribbon。

##### 优势

feign可以做到使用http请求远程服务时，就像掉了本地方法一样的体验，不需要经过常规的http client构造请求再解析返回数据，无需关注与远程的交互细节，更无需关注分布式环境开发



#### Spring Cloud Alibaba整合openFeign

引入依赖

```xml
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
  </dependency>
</dependencies>
```

示例代码

```java
/**
 *
 * @author JiangKangWei
 * @create 2022/8/19 16:18
 */
@FeignClient(name = "stock-service",path = "/stock")
public interface StockFeignService {

  @RequestMapping("add")
  public String add();

}

@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class OrderServer {

  @Bean
  public RestTemplate restTemplate(){
    return new RestTemplate();
  }

  public static void main(String[] args) {
    ConfigurableApplicationContext run = SpringApplication.run(OrderServer.class, args);

  }
}
```

#### open feign的日志级别

1. NONE：不记录任何日志(默认)
2. BASIC：仅记录请求方法
3. HEADERS：记录请求和响应的heard
4. FULL：记录请求和响应的header,body和元数据



#### 		spring cloud feign的自定义配置及使用

##### 日志配置

###### 全局日志配置：

```yml
#springboot 默认 的日志级别时info,feign默认的日志级别为debug,info>debug, feign的debug级别日志就不会输出
logging:
  level:
    com.it.alibaba.feign: debug
```

```java
@Configuration
public class FeignConfig {
  
  @Bean
  public Logger.Level feignLoggerLevel(){
    return Logger.Level.FULL;
  }
}
```

###### 局部日志配置

```java
@FeignClient(name = "stock-service",path = "/stock",configuration = FeignConfig.class)
public interface StockFeignService {

  @RequestMapping("add")
  public String add();
}





/**
 * 全局配置：使用 @Configuration 会将配置作用于所有的服务提供方
 * 局部配置：如果只想针对某一个服务提供方做配置，就不要加 @Configuration注解，同时讲这个类放在
 *        @FeignClient注解中的 configuration属性中
 */
public class FeignConfig {

  @Bean
  public Logger.Level feignLoggerLevel(){
    return Logger.Level.FULL;
  }
}



```



也可以使用配置文件配置日志级别，并区分服务提供方

```yml
feign:
  client:
    config:
      ##服务名，可分别配置多个
      stock-service:
        loggerLevel: BASIC
```

##### 超时时间配置

配置文件：

```yml
feign:
  client:
    config:
      ##服务名
      stock-service:
        #连接超时时间，默认两秒
        connectTimeOut: 5000
        #请求处理超时时间，默认五秒
        readTimeout: 10000
```

配置类：

```java
/**
 *
 * @author JiangKangWei
 * @create 2022/8/19 17:29
 */


@Configuration
public class FeignConfig {

  /**
   * 设置日志优先级，还需要再配置文件中修改spring boot 默认的日志有限级别为
   * @return
   */
  @Bean
  public Logger.Level feignLoggerLevel(){
    return Logger.Level.FULL;
  }

  @Bean
  public Request.Options options(){
    //1 连接超时时间，2 请求处理超时时间
    return new Request.Options(5000,10000);
  }
}
```



#### OpenFeign 自定义拦截器

##### 自定义拦截器主体：

```java
package com.it.alibaba.customer;
import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.context.annotation.Configuration;
/**
 *自定义feign 拦截器， 调用feign接口之前，会先通过这里，做一些统一配置
 * 可以在本类直接申明配置类注入，为了方便管理，这里注释掉配置类注解，放在Feignconfig中做统一管理
 * @author JiangKangWei
 * @create 2022/8/22 14:59
 */
//@Configuration
public class MyCustomerFeignInterceptor implements RequestInterceptor {

  @Override
  public void apply(RequestTemplate requestTemplate) {
    requestTemplate.header("UserCode","91785");
    requestTemplate.header("TenantId","10001");
  }
}
```

##### 	配置方式

###### 配置文件：

```yml
feign:
  client:
    config:
      ##服务名
      stock-service:
        #feign拦截器配置
        requestInterceptors[0]:
          com.it.alibaba.customer.MyCustomerFeignInterceptor
```

###### 配置类：

```
@Configuration
public class FeignConfig {

  /**
   * 设置日志优先级，还需要再配置文件中修改spring boot 默认的日志有限级别为
   * @return
   */
  @Bean
  public Logger.Level feignLoggerLevel(){
    return Logger.Level.FULL;
  }

  @Bean
  public Request.Options options(){
    //1 连接超时时间，2 请求处理超时时间
    return new Request.Options(5000,10000);
  }

  @Bean
  public MyCustomerFeignInterceptor requestInterceptor(){
    //自定义的feign拦截器
    return new MyCustomerFeignInterceptor();
  }
}
```



## Sentinel

### 作用

主要是为了解决微服务当中出现的可用性的问题，从而实现我们系统的高可用。

### 分布式系统遇到的问题

#### 可能引起服务器挂掉的原因有那些？

流量激增，被其他服务拖垮，异常没处理，缺乏依赖隔离，缓存问题(击穿，穿透)，线程池满，单点故障，负载不均，不稳定服务依赖





### 服务雪崩

#### 什么是服务雪崩效应

因服务提供者的不可用，导致服务调用者的不可用，并将不可用逐渐放大的过程就叫雪崩效应。

#### 导致服务不可用的原因

##### 激增流量

###### 1：导致CPU/Load飙高，无法正常处理请求

###### 2：打垮冷系统（数据库连接未创建，缓存未预热）

###### 3：消息投递速度过快，造成消息积压

##### 不稳定服务依赖

###### 1：慢sql卡爆连接池

###### 2：第三方服务不响应，卡满线程池

###### 3：业务调用链持续出现异常，产生大量副作用

##### 总结

在服务提供者不可用的时候，会出现大量重试的情况：用户重试，代码逻辑重试， 这些重试最终导致：进一步加大请求量。所以归根结底导致服务雪崩效应最根本的原因是：大量请求 线程同步等待 造成的资源耗尽。当服务调用者使用同步调用时，会产生大量的同步线程，占用系统资源。一旦线程资源被耗尽，服务调用者自身所提供的服务也将处于不可用状态，于是服务雪崩效应产生了。

#### 服务不可用解决方案

#### 可靠性，恢复性

![](..\图片\1661248582987.jpg)

#### 常见的容错机制：

##### 超时机制

再不做任何处理的情况下，服务提供者的不可用会导致消费者的请求线程等待，造成资源耗尽。加入超时机制，一旦超时就释放资源。由于资源释放的速度够快，一定程度上可以抑制资源耗尽的问题。



##### 服务限流

QPS:每秒钟的请求数。

可以使用压测工具Jmeter对接口进行压测，得到一个临界值，当请求数超过这个临界值做相应处理，如：返回提示，当前请求用户数量过多，请稍后重试。或者直接拒绝

![](../图片/1661247267863.jpg)

##### 隔离(不是很懂，需要再看看)

原理：

用户的请求将不再直接访问服务，而是通过线程池的空闲线程来访问服务，如果线程池已满，则会进行降级处理，用户的请求不会被阻塞，至少可以看到一个结果(返回友情提示)，而不是无休止等待或看到系统奔溃。

###### 服务熔断

![](../图片/img.png)

熔断机制一般是在消费端服务配置

###### 服务降级

有服务熔断，就必然会有服务降级，服务降级一般应用于弱依赖服务，降级之后可以在本服务记录日志存储相关数据，后续进行补偿处理，例如秒杀系统中的 积分服务，就属于弱依赖服务

#### sentinel介绍

[sentinel官网](https://github.com/alibaba/Sentinel/wiki)

##### sentinel是什么

![](../图片/1661342899125.jpg)



随着微服务的流行，服务和服务之间的稳定性变得越来越重要。 [Sentinel](https://github.com/alibaba/Sentinel) 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

[Sentinel](https://github.com/alibaba/Sentinel) 具有以下特征:

- **丰富的应用场景**： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。
- **完备的实时监控**： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
- **广泛的开源生态**： Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。
- **完善的 SPI 扩展点**： Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等

![](..\图片\1661343197882.jpg)



#### Sentinel使用

Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。

所说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:

1. 定义资源
2. 定义规则
3. 检验规则是否生效

##### 定义资源

###### 方式一：主流框架的默认适配

为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见: [主流框架的适配](https://github.com/alibaba/Sentinel/wiki/主流框架的适配)。

###### 方式二：抛出异常的方式定义资源

`SphU` 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 `BlockException`。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:

```java
// 1.5.0 版本开始可以利用 try-with-resources 特性（使用有限制）
// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。
try (Entry entry = SphU.entry("resourceName")) {
  // 被保护的业务逻辑
  // do something here...
} catch (BlockException ex) {
  // 资源访问阻止，被限流或被降级
  // 在此处进行相应的处理操作
}
```

**特别地**，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（`exit(count, args)`），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 `Tracer.trace(ex)` 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 `Tracer.trace(ex)`。

手动 exit 示例：

```java
Entry entry = null;
// 务必保证 finally 会被执行
try {
  // 资源名可使用任意有业务语义的字符串，注意数目不能太多（超过 1K），超出几千请作为参数传入而不要直接作为资源名
  // EntryType 代表流量类型（inbound/outbound），其中系统规则只对 IN 类型的埋点生效
  entry = SphU.entry("自定义资源名");
  // 被保护的业务逻辑
  // do something...
} catch (BlockException ex) {
  // 资源访问阻止，被限流或被降级
  // 进行相应的处理操作
} catch (Exception ex) {
  // 若需要配置降级规则，需要通过这种方式记录业务异常
  Tracer.traceEntry(ex, entry);
} finally {
  // 务必保证 exit，务必保证每个 entry 与 exit 配对
  if (entry != null) {
    entry.exit();
  }
}
```

热点参数埋点示例：

```java
Entry entry = null;
try {
    // 若需要配置例外项，则传入的参数只支持基本类型。
    // EntryType 代表流量类型，其中系统规则只对 IN 类型的埋点生效
    // count 大多数情况都填 1，代表统计为一次调用。
    entry = SphU.entry(resourceName, EntryType.IN, 1, paramA, paramB);
    // Your logic here.
} catch (BlockException ex) {
    // Handle request rejection.
} finally {
    // 注意：exit 的时候也一定要带上对应的参数，否则可能会有统计错误。
    if (entry != null) {
        entry.exit(1, paramA, paramB);
    }
}
```

`SphU.entry()` 的参数描述：

| 参数名    | 类型        | 解释                                                         | 默认值          |
| --------- | ----------- | ------------------------------------------------------------ | --------------- |
| entryType | `EntryType` | 资源调用的流量类型，是入口流量（`EntryType.IN`）还是出口流量（`EntryType.OUT`），注意系统规则只对 IN 生效 | `EntryType.OUT` |
| count     | `int`       | 本次资源调用请求的 token 数目                                | 1               |
| args      | `Object[]`  | 传入的参数，用于热点参数限流                                 | 无              |

**注意**：`SphU.entry(xxx)` 需要与 `entry.exit()` 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 `ErrorEntryFreeException` 异常。常见的错误：

- 自定义埋点只调用 `SphU.entry()`，没有调用 `entry.exit()`
- 顺序错误，比如：`entry1 -> entry2 -> exit1 -> exit2`，应该为 `entry1 -> entry2 -> exit2 -> exit1`

###### 方式三：返回布尔值方式定义资源

`SphO` 提供 if-else 风格的 API。用这种方式，当资源发生了限流之后会返回 `false`，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:

```java
  // 资源名可使用任意有业务语义的字符串
  if (SphO.entry("自定义资源名")) {
    // 务必保证finally会被执行
    try {
      /**
      * 被保护的业务逻辑
      */
    } finally {
      SphO.exit();
    }
  } else {
    // 资源访问阻止，被限流或被降级
    // 进行相应的处理操作
  }
```

**注意**：`SphO.entry(xxx)` 需要与 SphO.exit()`方法成对出现，匹配调用，位置正确，否则会导致调用链记录异常，抛出`ErrorEntryFreeException` 异常。

###### 方式四：注解方式定义资源

Sentinel 支持通过 `@SentinelResource` 注解定义资源并配置 `blockHandler` 和 `fallback` 函数来进行限流之后的处理。示例：

```java
// 原本的业务方法.
@SentinelResource(blockHandler = "blockHandlerForGetUser")
public User getUserById(String id) {
    throw new RuntimeException("getUserById command failed");
}

// blockHandler 函数，原方法调用被限流/降级/系统保护的时候调用
public User blockHandlerForGetUser(String id, BlockException ex) {
    return new User("admin");
}
```

注意 `blockHandler` 函数会在原方法被限流/降级/系统保护的时候调用，而 `fallback` 函数会针对所有类型的异常。请注意 `blockHandler` 和 `fallback` 函数的形式要求，更多指引可以参见 [Sentinel 注解支持文档](https://github.com/alibaba/Sentinel/wiki/注解支持)。

###### 方式五：异步调用支持

Sentinel 支持异步调用链路的统计。在异步调用中，需要通过 `SphU.asyncEntry(xxx)` 方法定义资源，并通常需要在异步的回调函数中调用 `exit` 方法。以下是一个简单的示例：

```java
try {
    AsyncEntry entry = SphU.asyncEntry(resourceName);

    // 异步调用.
    doAsync(userId, result -> {
        try {
            // 在此处处理异步调用的结果.
        } finally {
            // 在回调结束后 exit.
            entry.exit();
        }
    });
} catch (BlockException ex) {
    // Request blocked.
    // Handle the exception (e.g. retry or fallback).
}
```

`SphU.asyncEntry(xxx)` 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：

```
// 调用链类似于：
// -parent
// ---asyncResource
// ---syncResource
asyncEntry = SphU.asyncEntry(asyncResource);
entry = SphU.entry(normalResource);
```

若在异步回调中需要嵌套其它的资源调用（无论是 `entry` 还是 `asyncEntry`），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 `ContextUtil.runOnContext(context, f)` 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。示例如下：

```java
public void handleResult(String result) {
    Entry entry = null;
    try {
        entry = SphU.entry("handleResultForAsync");
        // Handle your result here.
    } catch (BlockException ex) {
        // Blocked for the result handler.
    } finally {
        if (entry != null) {
            entry.exit();
        }
    }
}

public void someAsync() {
    try {
        AsyncEntry entry = SphU.asyncEntry(resourceName);

        // Asynchronous invocation.
        doAsync(userId, result -> {
            // 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context
            ContextUtil.runOnContext(entry.getAsyncContext(), () -> {
                try {
                    // 此处嵌套正常的资源调用.
                    handleResult(result);
                } finally {
                    entry.exit();
                }
            });
        });
    } catch (BlockException ex) {
        // Request blocked.
        // Handle the exception (e.g. retry or fallback).
    }
}
```

此时的调用链就类似于：

```
-parent
---asyncInvocation
-----handleResultForAsync
```

更详细的示例可以参考 Demo 中的 [AsyncEntryDemo](https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java)，里面包含了普通资源与异步资源之间的各种嵌套示例。

#### Sentinel规则种类

Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。

Sentinel 支持以下几种规则：**流量控制规则**、**熔断降级规则**、**系统保护规则**、**来源访问控制规则** 和 **热点参数规则**。

##### 流量控制规则 (FlowRule)

###### 流量规则的定义

重要属性：

| Field           | 说明                                                         | 默认值                        |
| --------------- | ------------------------------------------------------------ | :---------------------------- |
| resource        | 资源名，资源名是限流规则的作用对象                           |                               |
| count           | 限流阈值                                                     |                               |
| grade           | 限流阈值类型，QPS 模式（1）或并发线程数模式（0）             | QPS 模式                      |
| limitApp        | 流控针对的调用来源                                           | `default`，代表不区分调用来源 |
| strategy        | 调用关系限流策略：直接、链路、关联                           | 根据资源本身（直接）          |
| controlBehavior | 流控效果（直接拒绝/WarmUp/匀速+排队等待），不支持按调用关系限流 | 直接拒绝                      |
| clusterMode     | 是否集群限流                                                 | 否                            |

同一个资源可以同时有多个限流规则，检查规则时会依次检查。

###### 通过代码定义流量控制规则

理解上面规则的定义之后，我们可以通过调用 `FlowRuleManager.loadRules()` 方法来用硬编码的方式定义流量控制规则，比如：

```
private void initFlowQpsRule() {
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule(resourceName);
    // set limit qps to 20
    rule.setCount(20);
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    rule.setLimitApp("default");
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

更多详细内容可以参考 [流量控制](https://github.com/alibaba/Sentinel/wiki/流量控制)。

###### 阈值类型

QPS模式：

一秒超过指定count数量的请求进来，就会触发规则

并发线程数模式：

如果线程数(count)设置为1,意思就是，等待线程数最大为一，之后再有一个请求进来，并且之前那个线程还在等待，未执行完成状态，就会触发规则。

测试时候发现个问题，同一个浏览器触发不了 为啥？

###### 流控模式

直接：

资源调用达到设置的阈值后直接被流控抛出异常。

关联：

![](../图片/img_1.png)

关联资源达到设置的阈值后，受影响的不是关联的资源，而是设置的资源。

![](../图片/img_3.png)

链路：

根据调用链路入口限流。

![image-20220830112831872](笔记.assets/image-20220830112831872.png)

![image-20220830113421533](笔记.assets/image-20220830113421533.png)

配置文件需要配置：

```yml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: 127.0.0.1:8080
      web-context-unify: false ##true:将调用链路收敛，false:关闭收敛
```

###### 流控效果

<font color="Salmon" size="4">以QPS阈值类型为例</font>

<font color="Salmon" size="4">直接</font>

​	每秒请求量到达阈值后，这一秒内的其他请求直接失败。

<font color="Salmon" size="4">Warm up(预热/冷启动)</font>

​	冷启动的初始阈值为：threshold/3 （阈值除三），由这个值再预热时长内，到达设置的阈值。

​	用白话讲就是，当阈值设置为3(初始阈值为1)，预热时长为5秒，在这五秒之内，阈值会由3逐渐变为5，用jmeter做测试，每秒钟发送三个请求，持续十秒，那么可以观察到的现象就是 在第一秒的时候，三个请求中只有一个请求成功....后续时间内请求成功数逐渐上升，在第五秒预热完成，之后的请求全部成功。

<font color="Salmon" size="4">匀速排队模式</font>

Sentinel 匀速排队等待策略是 Leaky Bucket 算法结合虚拟队列等待机制实现的。

> **注意**：
>
> 1 匀速排队模式暂时不支持 QPS > 1000 的场景。
>
> 2 当匀速器生效的时候，规则的限流类型一定是 `RuleConstant.GRADE_QPS`，否则该规则将不生效。



##### 熔断降级规则 (DegradeRule)

熔断降级规则包含下面几个重要的属性：

| Field              | 说明                                                         | 默认值     |
| ------------------ | ------------------------------------------------------------ | ---------- |
| resource           | 资源名，即规则的作用对象                                     |            |
| grade              | 熔断策略，支持慢调用比例/异常比例/异常数策略                 | 慢调用比例 |
| count              | 慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值 |            |
| timeWindow         | 熔断时长，单位为 s                                           |            |
| minRequestAmount   | 熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入） | 5          |
| statIntervalMs     | 统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）   | 1000 ms    |
| slowRatioThreshold | 慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）           |            |

同一个资源可以同时有多个降级规则。

理解上面规则的定义之后，我们可以通过调用 `DegradeRuleManager.loadRules()` 方法来用硬编码的方式定义流量控制规则。

```
private void initDegradeRule() {
    List<DegradeRule> rules = new ArrayList<>();
    DegradeRule rule = new DegradeRule();
    rule.setResource(KEY);
    // set threshold RT, 10 ms
    rule.setCount(10);
    rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);
    rule.setTimeWindow(10);
    rules.add(rule);
    DegradeRuleManager.loadRules(rules);
}
```

更多详情可以参考 [熔断降级](https://github.com/alibaba/Sentinel/wiki/熔断降级)。

##### 系统保护规则 (SystemRule)

Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。

系统规则包含下面几个重要的属性：

| Field             | 说明                                   | 默认值      |
| ----------------- | -------------------------------------- | ----------- |
| highestSystemLoad | `load1` 触发值，用于触发自适应控制阶段 | -1 (不生效) |
| avgRt             | 所有入口流量的平均响应时间             | -1 (不生效) |
| maxThread         | 入口流量的最大并发数                   | -1 (不生效) |
| qps               | 所有入口资源的 QPS                     | -1 (不生效) |
| highestCpuUsage   | 当前系统的 CPU 使用率（0.0-1.0）       | -1 (不生效) |

理解上面规则的定义之后，我们可以通过调用 `SystemRuleManager.loadRules()` 方法来用硬编码的方式定义流量控制规则。

```
private void initSystemRule() {
    List<SystemRule> rules = new ArrayList<>();
    SystemRule rule = new SystemRule();
    rule.setHighestSystemLoad(10);
    rules.add(rule);
    SystemRuleManager.loadRules(rules);
}
```

注意系统规则只针对入口资源（EntryType=IN）生效。更多详情可以参考 [系统自适应保护文档](https://github.com/alibaba/Sentinel/wiki/系统自适应限流)。

##### 访问控制规则 (AuthorityRule)

很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的访问控制（黑白名单）的功能。黑白名单根据资源的请求来源（`origin`）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。

授权规则，即黑白名单规则（`AuthorityRule`）非常简单，主要有以下配置项：

- `resource`：资源名，即规则的作用对象
- `limitApp`：对应的黑名单/白名单，不同 origin 用 `,` 分隔，如 `appA,appB`
- `strategy`：限制模式，`AUTHORITY_WHITE` 为白名单模式，`AUTHORITY_BLACK` 为黑名单模式，默认为白名单模式

更多详情可以参考 [来源访问控制](https://github.com/alibaba/Sentinel/wiki/黑白名单控制)。

##### 热点规则 (ParamFlowRule)

详情可以参考 [热点参数限流](https://github.com/alibaba/Sentinel/wiki/热点参数限流)。

##### 查询更改规则

引入了 transport 模块后，可以通过以下的 HTTP API 来获取所有已加载的规则：

```
http://localhost:8719/getRules?type=<XXXX>
```

其中，`type=flow` 以 JSON 格式返回现有的限流规则，degrade 返回现有生效的降级规则列表，system 则返回系统保护规则。

获取所有热点规则：

```
http://localhost:8719/getParamRules
```

##### 定制自己的持久化规则

上面的规则配置，都是存在内存中的。即如果应用重启，这个规则就会失效。因此我们提供了开放的接口，您可以通过实现 [`DataSource`](https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java) 接口的方式，来自定义规则的存储数据源。通常我们的建议有：

- 整合动态配置系统，如 ZooKeeper、[Nacos](https://github.com/alibaba/Nacos)、Apollo 等，动态地实时刷新配置规则
- 结合 RDBMS、NoSQL、VCS 等来实现该规则
- 配合 Sentinel Dashboard 使用

更多详情请参考 [动态规则配置](https://github.com/alibaba/Sentinel/wiki/动态规则扩展)。

## Seata

## 事务简介：

###### [理解什么是AT、TCC、Saga以及本地锁、全局锁、seata的事务级别](https://blog.csdn.net/m0_45406092/article/details/121263208)

###### [MySQL事务隔离级别详解](https://blog.csdn.net/m0_45406092/article/details/109608471)

#### ![image-20220831143647040](笔记.assets/image-20220831143647040.png)

## 













